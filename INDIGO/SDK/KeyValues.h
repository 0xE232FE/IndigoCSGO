#pragma once

#include "SDK.h"

namespace SDK
{
	class KeyValues
	{
	public:
		static void SetUseGrowableStringTable( bool bUseGrowableTable );

		KeyValues( const char *setName )
		{
			Init();
			SetName( setName );
		}

		class AutoDelete
		{
		public:
			explicit inline AutoDelete( KeyValues *pKeyValues ) : m_pKeyValues( pKeyValues ) {}
			explicit inline AutoDelete( const char *pchKVName ) : m_pKeyValues( new KeyValues( pchKVName ) ) {}
			inline ~AutoDelete( void ) { if ( m_pKeyValues ) m_pKeyValues->deleteThis(); }
			inline void Assign( KeyValues *pKeyValues ) { m_pKeyValues = pKeyValues; }
			KeyValues *operator->() { return m_pKeyValues; }
			operator KeyValues *( ) { return m_pKeyValues; }
		private:
			AutoDelete( AutoDelete const &x ); // forbid
			AutoDelete & operator= ( AutoDelete const &x ); // forbid
			KeyValues *m_pKeyValues;
		};

		const char *GetName() const;
		void SetName( const char *setName )
		{
			m_iKeyName = 2;
		}

		int GetNameSymbol() const { return m_iKeyName; }

		void UsesEscapeSequences( bool state ); // default false
		void UsesConditionals( bool state ); // default true

		KeyValues *FindKey( const char *keyName , bool bCreate = false );
		KeyValues *FindKey( int keySymbol ) const;
		KeyValues *CreateNewKey();		// creates a new key, with an autogenerated name.  name is guaranteed to be an integer, of value 1 higher than the highest other integer key name
		void AddSubKey( KeyValues *pSubkey );	// Adds a subkey. Make sure the subkey isn't a child of some other keyvalues
		void RemoveSubKey( KeyValues *subKey );	// removes a subkey from the list, DOES NOT DELETE IT

		KeyValues *GetFirstSubKey() { return m_pSub; }	// returns the first subkey in the list
		KeyValues *GetNextKey() { return m_pPeer; }		// returns the next subkey
		void SetNextKey( KeyValues * pDat );
		KeyValues *FindLastSubKey();	// returns the LAST subkey in the list.  This requires a linked list iteration to find the key.  Returns NULL if we don't have any children

		KeyValues* GetFirstTrueSubKey();
		KeyValues* GetNextTrueSubKey();

		KeyValues* GetFirstValue();	// When you get a value back, you can use GetX and pass in NULL to get the value.
		KeyValues* GetNextValue();

		// Data access
		int   GetInt( const char *keyName = NULL , int defaultValue = 0 );
		float GetFloat( const char *keyName = NULL , float defaultValue = 0.0f );
		const char *GetString( const char *keyName = NULL , const char *defaultValue = "" );
		const wchar_t *GetWString( const char *keyName = NULL , const wchar_t *defaultValue = L"" );
		void *GetPtr( const char *keyName = NULL , void *defaultValue = (void*)0 );
		bool GetBool( const char *keyName = NULL , bool defaultValue = false );
		bool  IsEmpty( const char *keyName = NULL );

		// Data access
		int   GetInt( int keySymbol , int defaultValue = 0 );
		float GetFloat( int keySymbol , float defaultValue = 0.0f );
		const char *GetString( int keySymbol , const char *defaultValue = "" );
		const wchar_t *GetWString( int keySymbol , const wchar_t *defaultValue = L"" );
		void *GetPtr( int keySymbol , void *defaultValue = (void*)0 );
		bool  IsEmpty( int keySymbol );

		// Key writing
		void SetWString( const char *keyName , const wchar_t *value );
		void SetString( const char *keyName , const char *value );
		void SetInt( const char *keyName , int value );
		void SetUint64( const char *keyName , UINT value );
		void SetFloat( const char *keyName , float value );
		void SetPtr( const char *keyName , void *value );
		void SetBool( const char *keyName , bool value ) { SetInt( keyName , value ? 1 : 0 ); }

		KeyValues& operator=( KeyValues& src );

		// Adds a chain... if we don't find stuff in this keyvalue, we'll look
		// in the one we're chained to.
		void ChainKeyValue( KeyValues* pChain );

		// Allocate & create a new copy of the keys
		KeyValues *MakeCopy( void ) const;

		// Make a new copy of all subkeys, add them all to the passed-in keyvalues
		void CopySubkeys( KeyValues *pParent ) const;

		// Clear out all subkeys, and the current value
		void Clear( void );

		// Data type
		enum types_t
		{
			TYPE_NONE = 0 ,
			TYPE_STRING ,
			TYPE_INT ,
			TYPE_FLOAT ,
			TYPE_PTR ,
			TYPE_WSTRING ,
			TYPE_COLOR ,
			TYPE_UINT64 ,
			TYPE_NUMTYPES ,
		};
		types_t GetDataType( const char *keyName = NULL );

		// Virtual deletion function - ensures that KeyValues object is deleted from correct heap
		void deleteThis();

		void SetStringValue( char const *strValue );

		// unpack a key values list into a structure
		void UnpackIntoStructure( struct KeyValuesUnpackStructure const *pUnpackTable , void *pDest , size_t DestSizeInBytes );

		// Process conditional keys for widescreen support.
		bool ProcessResolutionKeys( const char *pResString );

		// Dump keyvalues recursively into a dump context
		bool Dump( class IKeyValuesDumpContext *pDump , int nIndentLevel = 0 );

		// Merge in another KeyValues, keeping "our" settings
		void RecursiveMergeKeyValues( KeyValues *baseKV );

	public:
		KeyValues( KeyValues& );	// prevent copy constructor being used

									// prevent delete being called except through deleteThis()
		~KeyValues();

		KeyValues* CreateKey( const char *keyName );

		KeyValues* CreateKeyUsingKnownLastChild( const char *keyName , KeyValues *pLastChild );
		void AddSubkeyUsingKnownLastChild( KeyValues *pSubKey , KeyValues *pLastChild );

		void RecursiveCopyKeyValues( KeyValues& src );
		void RemoveEverything();

		void Init()
		{
			m_iKeyName = -1;
			m_iDataType = TYPE_NONE;

			m_pSub = NULL;
			m_pPeer = NULL;
			m_pChain = NULL;

			m_sValue = NULL;
			m_wsValue = NULL;
			m_pValue = NULL;

			m_bHasEscapeSequences = false;

			// for future proof
			memset( unused , 0 , sizeof( unused ) );
		}

		void FreeAllocatedValue();
		void AllocateValueBlock( int size );

		int m_iKeyName;	// keyname is a symbol defined in KeyValuesSystem

						// These are needed out of the union because the API returns string pointers
		char *m_sValue;
		wchar_t *m_wsValue;

		// we don't delete these
		union
		{
			int m_iValue;
			float m_flValue;
			void *m_pValue;
			unsigned char m_Color[4];
		};

		char	   m_iDataType;
		char	   m_bHasEscapeSequences; // true, if while parsing this KeyValue, Escape Sequences are used (default false)
		char	   m_bEvaluateConditionals; // true, if while parsing this KeyValue, conditionals blocks are evaluated (default true)
		char	   unused[1];

		KeyValues *m_pPeer;	// pointer to next key in list
		KeyValues *m_pSub;	// pointer to Start of a new sub key list
		KeyValues *m_pChain;// Search here if it's not in our list

	private:
		// Statics to implement the optional growable string table
		// Function pointers that will determine which mode we are in
		static int( *s_pfGetSymbolForString )( const char *name , bool bCreate );
		static const char *( *s_pfGetStringForSymbol )( int symbol );

	public:
		// Functions that invoke the default behavior
		static int GetSymbolForStringClassic( const char *name , bool bCreate = true );
		static const char *GetStringForSymbolClassic( int symbol );

		// Functions that use the growable string table
		static int GetSymbolForStringGrowable( const char *name , bool bCreate = true );
		static const char *GetStringForSymbolGrowable( int symbol );

		// Functions to get external access to whichever of the above functions we're going to call.
		static int CallGetSymbolForString( const char *name , bool bCreate = true ) { return s_pfGetSymbolForString( name , bCreate ); }
		static const char *CallGetStringForSymbol( int symbol ) { return s_pfGetStringForSymbol( symbol ); }

		bool LoadFromBuffer( KeyValues *pThis , const char *pszFirst , const char *pszSecond , PVOID pSomething = 0 , PVOID pAnother = 0 , PVOID pLast = 0 );
	};
}